#include<stdio.h>

// char 형이 1byte 로 8bit 연산을 한다.

//--------비트 연산자----------
// 10진수를 2진수 형태로 각 비트별로 연산을 진행
// &(비트 AND 연산) : 대응되는 비트가 모두 1이면 1을 반환		ex) 0101 1000 = 88, 0100 1100 = 76	88 & 76 -> 0100 1000 = 72
// |(비트  OR 연산) : 대응되는 비트 중 하나라도 1이면 1을 반환	ex) 0101 1100 =  92
// ^(비트 XOR 연산) : 대응되는 비트가 서로 다르면 1을 반환		ex) 0001 0100 = 20
// ~(비트 NOT 연산) : 비트가 0이면 1, 1이면 0으로 반전			ex) ~88 = 1010 0111 ->-89	, ~76 = 1011 0011
// ~(틸드)
// <<(Left Shift 연산) : 비트들을 모두 지정 수 만큼 왼쪽으로 이동  ex)  76, << 1  -> 1001 1000 = 152
// >>(Right Shift 연산) : 비트들을 모두 지정 수 만큼 오른쪽으로 이동 ex)  88, >> 2  -> 0001 0110 = 22
//

//

// 2진법 표기 :  10 -> 0000 0110 ,     35 -> 0010 0001 ,	 46 -> 0010 1110,	 31 -> 0001 1111,	62 ->  0011 1110 ,	 255 -> 1111 1110

// 2진법의 - 표기는 가장 앞자리로 표현
// 보수 : 보충해주는 수
// 1의 보수 : 모든 비트를 1로 만들기 위해 보충해주는 수 -> 0의 보수를 찾을때 에러가 발생하기 때문에 2의 보수로 대체한다.
// 10 = 0000 1010 의 보수
//-10 = 1111 0101 -> 1의 보수
//		0000 1010   
//-10 = 1111 0110 -> 2의 보수
//		0000 1001
//0 = 0000 0000
//  = 1111 1111 -> 1의 보수
//  = 0000 0000 -> 2의 보수
// 2진수를 통해 -10을 추론하려면 역으로 1의 보수를 구해야한다.
// 2의 보수 : 1의 보수에서 1bit를 더해주면 된다.
// 현재는 2의 보수로 사용

// -128 ~ 127 인 bit 환경에서 부호비트를 사용하지 않게 강제 형변환을 하려면 unsigned char 를 사용하면 된다.  ex) (unsigned char)~num4, (unsigned short)~num4 



int main()
{


	// 8진수  10 ->	012	, 35 ->	043	, 46 ->	056	, 31 ->	037	, 62 ->	076	, 255 -> 377
	// 16진수 10	->	0xa	, 35 ->	0x23	, 46 ->	0x2e	, 31 ->	0x1f	, 62 ->	0x3e	, 255 -> 0xff	

	// 8진수 표기법 : 0yy
	// 16진수 표기법 : 0xyy


	printf("비트 AND 연산 결과 : %d\n", 88 & 76);
	printf("비트  OR 연산 결과 : %d\n", 88 | 76);
	printf("비트 XOR 연산 결과 : %d\n", 88 ^ 76);
	printf("비트   ~ 연산 결과 : %d\n", ~88);
	printf("Left Shift 연산 결과 : %d\n", 76 << 1);
	printf("Right Shift 연산 결과 : %d\n", 88 >> 2 );
	
	//num1 = 78 , num2 = 37,  num3 = 18 , num4 = 4, num5 = 106
	//num1 | num3 = 36
	//num5 & num2 = 32
	//num4 ^ num3 = 22
	//~num4 = 251
	//num4<<3 = 32
	//num3 >> 1 = 9


	// -59
	// 59 -> 0011 1011    
	//       1100 0100
		//   1100 0101

	// -7
	// 7 -> 0000 0111   
	//		1111 1000
	//		1111 1001

	// -100
	// 100 -> 0110 0100  
	//		  1001 1011
	//		  1001 1100

	// 1000 0000 = -
	// 1000 0000 = -128		// 2의 보수를 했을때 가장 왼쪽에 있는 부호 비트는 부호비트로써가 아니라 값으로 사용// 2진수의 가장 작은 수

	// 0111 1111 = 127		// 2진수의 가장 큰 수

	return 0;
}